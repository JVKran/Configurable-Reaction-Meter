#include <stdio.h>
#include <stdlib.h>

#include <string.h>
#include <stdint.h>
#include <stdbool.h>

#include <io.h>
#include <sys/alt_irq.h>

#include "includes.h"
#include <altera_avalon_pio_regs.h>

// Application logic definitions.
#define	  FIXED_DELAY		   2000		// Must be between 0 and 5000ms.
#define   MIN_RESP_TIME		   80

// Hardware definitions.
#define   LED_AMT			   10
#define   START_KEY			   1
#define   RESP_KEY			   2

// States
#define   SYS_COUNTING 3
#define   SYS_STOP 4

// Task configuration.
#define   TASK_STACKSIZE       1024
OS_STK    task1_stk[TASK_STACKSIZE];
#define   TASK1_PRIORITY      1		// Period of 1ms (highest priority)

// IRQ-enabled custom platform designer component
#define	  IRQ_ID			   1
#define	  IRQ_CONTROLLER	   0

// Synchronisation mechanisms.
OS_EVENT *running_sem, *start_sem, *stop_sem, *start_counting_sem, *restart_sem;

void show_score(unsigned int score){
	int data = score % 10;
	data |= (score / 10 % 10) << 4;
	data |= (score / 100 % 10) << 8;
	data |= (score / 1000 % 10) << 12;
	IOWR_32DIRECT(SSD_CONTROLLER_BASE, 4, data);
}

void show_tries(unsigned int tries){
	int data = tries % 10;
	data |= (tries / 10 % 10) << 4;
	IOWR_32DIRECT(SSD_CONTROLLER_BASE, 0, data);
}

int rotate_left(int num, int shift){
    return (num << shift) | (num >> (9 - shift));
}

void reaction_meter(void* pdata){
	INT8U ret = OS_NO_ERR;
	uint16_t highscore = UINT16_MAX;
	uint16_t response_time, leds = 0;
	uint8_t tries = 0;

	enum states {IDLE, START, COUNT, STOP};
	enum states state = IDLE;

	while (1){
		switch(state){
		case IDLE: {
			if(highscore != UINT16_MAX){
				show_score(highscore);
			} else {
				show_score(0);
			}
			show_tries(tries++);
			leds = 0;
			IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BASE, leds);
			OSSemPend(start_sem, 0, &ret);
			state = START;
			break;
		}
		case START: {
			show_score(0);
			OSSemPend(start_counting_sem, 0, &ret);
			state = COUNT;
			break;
		}
		case COUNT: {
			enum states next_state = IDLE;
			for(uint16_t time = 0; time < 20; time++){
				leds <<= 1;
				leds |= 1UL;
				IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BASE, leds);
				OSSemPend(stop_sem, 100, &ret); 	// Wait 1ms at max.
				if(ret != OS_TIMEOUT){
					response_time = IORD_16DIRECT(RESPONSE_TIME_METER_0_BASE, 2);
					if(response_time >= MIN_RESP_TIME){
						printf("Responded within %ims!\n", response_time);
						next_state = STOP;
					}
					break;
				}
			}
			state = next_state;
			break;
		}
		case STOP: {
			show_score(response_time);
			bool new_highscore = false;
			if(response_time < highscore){
				highscore = response_time;
				new_highscore = true;
			}
			while(true){
				OSSemPend(restart_sem, 100, &ret);
				if(ret != OS_TIMEOUT){
					break;
				}
				if(new_highscore){
					leds = rotate_left(leds, 1);
					IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BASE, leds);
				}
			}
			state = IDLE;
			break;
		}
		}
	}
}

static void isr(void * isr_context){
	uint16_t state = IORD_16DIRECT(RESPONSE_TIME_METER_0_BASE, 0);
	if(state == 3){
		OSSemPost(start_counting_sem);
	} else if(state == 1){
		OSSemPost(start_sem);
	} else if(state == SYS_STOP) {
		OSSemPost(stop_sem);
	} else if (state == 0){
		OSSemPost(restart_sem);
	}
	show_tries(state);
}

static void init_response_meter(){
#ifdef FIXED_DELAY
	IOWR_16DIRECT(RESPONSE_TIME_METER_0_BASE, 0, FIXED_DELAY);
#else
	IOWR_16DIRECT(RESPONSE_TIME_METER_0_BASE, 0, 0);
#endif
}

int main(void){
	start_sem = OSSemCreate(0);
	start_counting_sem = OSSemCreate(0);
	running_sem = OSSemCreate(0);
	stop_sem = OSSemCreate(0);
	restart_sem = OSSemCreate(0);

	IOWR_16DIRECT(RESPONSE_TIME_METER_0_BASE, 0, 0);
	alt_ic_isr_register(IRQ_CONTROLLER, IRQ_ID, isr, 0, 0x0);

	OSTaskCreateExt(reaction_meter,
                  NULL,
                  (OS_STK*)&task1_stk[TASK_STACKSIZE-1],
                  TASK1_PRIORITY,
                  TASK1_PRIORITY,
                  task1_stk,
                  TASK_STACKSIZE,
                  NULL,
                  0);

	OSStart();
	return 0;
}
